1. Security Plan (verifiable head/crypto safety) plan and motivation
  - the issue:
    - any software using libp2p can complete a base transport/security handshake if it knows our multiaddr
    - without extra policy, that means unknown code can momentarily connect and try to open streams
  - what i changed now:
    - verack runs immediately on connection; non-handshake streams are blocked until verification
    - if verack fails, we close the peer (the whole connection), not just the stream
  - going further (planned):
    - admission: add an application credential to verack (HMAC proof over both sides’ nonces + peer IDs); only nodes with our secret pass
    - state summary: advertise an append-only “verifiable head” (head CID + height) for a simple G‑set log; this is not admission, it’s for progress/sync
    - after verack: optionally fetch the suffix from the advertised head and validate links to converge state. maybe, depending on time.
  - why this approach:
    - keeps security/auth at the app boundary we control; reduces junk traffic; simple to operate (RELATIVELY)...
    - the verifiable head gives a monotone progress signal we can reason about and use to schedule sync
      - which i should maybe quit trying to shoehorn into this system.
  - what it’s not:
    - not a replacement for libp2p crypto; not a public‑internet firewall
    - we may still see a base connection from unknown software, but it’s dropped immediately on failed verack
  - reference:
    - implementation plan lives in docs/sec_todo.txt (credential flow, log format, sync, tests)

2. g-set inclusion and monotonicity
  - what is it:
    - a G‑set is a grow‑only set: you can add elements, you never remove them
    - in this system, the elements can be simple facts like “peer X passed verack here” (or later, events in an append‑only log)
  - what it does for me:
    - gives a clean, single‑direction notion of “progress”: once something is learned, it stays learned
    - i can summarize progress with a small number (|G|) or a head pointer (CID) instead of shipping the whole set
  - how we keep it monotone:
    - only ever perform set‑add; no deletes, no rewrites
    - persist the adds; on restart, reload them; the count/height never goes backwards
    - when two nodes sync, they union their facts (set union) — still only growth
    - if/when we use an append‑only log, each block links to the previous head; that structure enforces “no rollback”
  - why i want monotonicity:
    - monotone state is easy to reason about (CALM): convergence without coordination and fewer locky/fragile protocols
    - no rollbacks means simpler error handling and fewer weird edge cases under partial failure
    - it’s cheap to compare/schedule: higher height likely has more to teach me; i can fetch a suffix and be done
    - also plays nicely with background gossip: repeated unions are idempotent, so “try again later” is safe