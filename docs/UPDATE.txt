1. Security Plan (verifiable head/crypto safety) plan and motivation
  - the issue:
    - any software using libp2p can complete a base transport/security handshake if it knows our multiaddr
    - without extra policy, that means unknown code can momentarily connect and try to open streams
  - what i changed now:
    - verack runs immediately on connection; non-handshake streams are blocked until verification
    - if verack fails, we close the peer (the whole connection), not just the stream
  - what i changed (admission mode):
    - tokens: per-node token signed by a CA; carried in verack version; verified at connection time
    - optional by default: if no token envs set, node runs open (public), like IPFS at the app layer
    - private when configured: set SNG40_CA_PUBS and SNG40_TOKEN (or SNG40_REQUIRE_TOKEN=true) to require admission
    - state summary (still planned): advertise a verifiable head (head CID + height) for a simple G-set log; for progress/sync, not admission
    - after verack: optionally fetch suffix from head to converge state (time permitting)
  - why this approach:
    - keeps security/auth at the app boundary we control; reduces junk traffic; simple to operate (RELATIVELY)...
    - the verifiable head gives a monotone progress signal we can reason about and use to schedule sync
      - which i should maybe quit trying to shoehorn into this system.
  - what it’s not:
    - not a replacement for libp2p crypto; not a public‑internet firewall
    - we may still see a base connection from unknown software, but it’s dropped immediately on failed verack
  - reference:
    - implementation plan lives in docs/sec_todo.txt (credential flow, log format, sync, tests)
  - benefits of this decision:
    - mirrors IPFS’s open-by-default model while enabling ad hoc private nets via user-supplied CA keys
    - simple ops: no PSK distribution; just a CA pubkey and per-node tokens
    - lets third parties bring their own trust root to form independent private clusters

2. g-set inclusion and monotonicity
  - what is it:
    - a G‑set is a grow‑only set: you can add elements, you never remove them
    - in this system, the elements can be simple facts like “peer X passed verack here” (or later, events in an append‑only log)
  - what it does for me:
    - gives a clean, single‑direction notion of “progress”: once something is learned, it stays learned
    - i can summarize progress with a small number (|G|) or a head pointer (CID) instead of shipping the whole set
  - how we keep it monotone:
    - only ever perform set‑add; no deletes, no rewrites
    - persist the adds; on restart, reload them; the count/height never goes backwards
    - when two nodes sync, they union their facts (set union) — still only growth
    - if/when we use an append‑only log, each block links to the previous head; that structure enforces “no rollback”
  - why i want monotonicity:
    - monotone state is easy to reason about (CALM): convergence without coordination and fewer locky/fragile protocols
    - no rollbacks means simpler error handling and fewer weird edge cases under partial failure
    - it’s cheap to compare/schedule: higher height likely has more to teach me; i can fetch a suffix and be done
    - also plays nicely with background gossip: repeated unions are idempotent, so “try again later” is safe
  - where it happens in code:
    - `stack` creation wires up `Datastore` and `BlockSvc`, the substrate for the G‑set
    - handshake registration is done after `stack` exists so head/height are advertised
    - on success, adds are recorded via `AppendPeerAdded(ctx, stack.Datastore, stack.BlockSvc, <peer>)`
    - runs in: `run` (dialer + gossip timers), `connect` (explicit connect), `get` (inline fetch with static router)
    - ensuring `stack` exists before these paths makes G‑set additions consistent from process start