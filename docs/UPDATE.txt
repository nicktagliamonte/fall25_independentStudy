1. how does libp2p VERACK?
  - it sort of doesn't! in libp2p connections go through an "upgrade" to negotiate mutually supported protocols, but libp2p itself is low-level enough that sharing broad connection methods and security versions suffices:
    - the upgrade transforms a raw transport connection (TCP or QUIC, etc) into a fully featured libp2p connection that supports 
      - crypto ID verification
      - encryption
      - multiplexed streams
      - negotiated app protocols
  - the libp2p process is to
    1. dial transport (tcp/quic/etc)
      - gives you a raw net.Conn or quic.Connection
    2. negotiate security (noise or TLS)
      - if the two peers share no sec protocol, the upgrade fails and the connection is closed
      - else, the upgrader wraps that connection with a security transport
      - this is where the handshake that provides each side's PeerID is done (verifies their public keys)
    3. stream muxer is negotiated (yamux/mplex)
      - if there's no common muxer, again upgrade fails and connection is closed
    4. connection is finalized
      - the upgrader now wraps all the above in a libp2p.Conn that emits conn events to the network stack
    5. per-stream protocol is negotiated via multistream select
      - after the connection is successful, a protocol runs to exchange agent strings, supported protocols, public listen addrs, etc
      - peers use this to discover if their higher-level protocols (bitswap, gossipsub) are compatible

1.5. how is this handled in code that uses libp2p?
  - use multiple options set in Host with a list of sec transports and muxers to increase fw/bw compatability
  - version your protocol IDs and support a small matrix

1.75. how is it handled in boxo?
  - by the libp2p runtime!
    - the initiator proposes, for example, bitswap 1.2.0
    - the responder accepts or rejects
    - if rejected, the initiator will retry with older versions
  - but in practice, bitswap is backwards compatible
    - nodes register handlers for multiple protocol IDs by default
    - when a remote peer connects, libp2p's protocol negotiation picks the highest mutually supported one
    - the wire format across the vers is kept stable (minor ver updates introduce optional fields only, as policy)
  - if NO mutually supported ver exists:
    - stream negotiation fails (throws ErrNoMatchingProtocol)
    - bitswap's peer manager marks the peer as unusable for exchange purposes
    - the connection itself stays open (on the libp2p level) bcause other protocols can or will still work (i.e. Ping, etc)
    - custom event handling COULD be written to close the conn if this sort of ver incompatability is encountered

1.99. cited sources:
  - bitswap/network/bsnet/ipfs_impl.go
  - bitswap/message/pb/message.proto
  - bitswap/network/interface.go
  - go-libp2p/p2p/protocol/multistream

2. meld the two bins into a single, symmetric protocol
  - one binary: `cmd/node` with run/put/connect/get
    - symmetrical roles; any node can serve wants and fetch
  - flags: --listen repeatable; sane tcp+quic defaults
    - tcp always on; quic best-effort (envs may block udp)
  - run: prints peer id + addrs; can background with --background and optional --log
    - control file path configurable via --control
  - control plane: local http daemon (127.0.0.1) with /put, /connect, /get; writes /tmp/fall25_node/daemon.json
    - self-dial guard: /connect and /get short-circuit when peer==self
  - non-daemon path still supported with --no-daemon for simple two-terminal tests
    - helpful for debugging and perf sanity
  - get uses a dynamic router (or static peer) not a dht; strictly null router policy
    - provider is injected per request; no global discovery
  - put/get support --file and --out for large payloads; daemon encodes data as base64
    - out path writes atomically (single write), no streaming yet
  - http debug: optional --http-debug to expose /cid/<cid> for quick reads
    - only for local dev; not for production use
  - helpers: common banner, dial timeout helpers; cleaner output
  - docs: exact no-daemon commands added for copy/paste flows

2.5. testing
  - terminal a: put --serve, copy peerid+addr+cid; terminal b: get with those fields
  - daemon mode: run --background, then put/get in separate terminals; prompt returns immediately
    - client timeouts increased to cover dial+fetch
  - verified cross direction a↔b; file output writes to Desktop/out.txt as expected
    - manual spot-check on contents match

2.99. hardening pass (late stage)
  - nat/relay: enabled nat service + relay client for better reachability; left server roles for later
    - next: add relay hints, autonat metrics
  - content routing: explicitly null router; no dht ever; supports explicit peer hints and local daemon routing
    - future: acan integration for provider lists
  - persistence: --key to persist libp2p key; --store to persist blockstore (leveldb)
    - keys stored as pem; blocks via leveldb-backed blockstore
  - anti-pattern note: dhts are out of scope; “ipfs minus dht” is the rule